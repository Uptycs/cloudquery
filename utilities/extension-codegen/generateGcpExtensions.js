/*
 * Copyright (c) 2020 Uptycs, Inc. All rights reserved
 */

'use strict';

const { pope } = require('pope');
const argv = require('optimist').argv;
const fs = require('fs');
const templates = require('./gcpTemplates');

const helpText = `
  Usage: node generateGcpExtension.js <destination-dir>
  `;

// We should allow only enable or disable not both
if (argv.h || argv.help || !argv._ || !argv._.length) {
  console.log(helpText);
  process.exit();
}

const outDir = argv._[0];
const configDir = outDir + '/config';
const pluginsConfig = JSON.parse(fs.readFileSync(configDir + '/plugins.json', 'utf8'));

const osqType2ColumnDef = new Map([
  ['text', 'TextColumn'],
  ['string', 'TextColumn'],
  ['integer', 'IntegerColumn'],
  ['bigint', 'BigIntColumn'],
  ['double', 'DoubleColumn']
]);

const comment = `// Do not edit this file.
// This file is generated by the following command.
// ${argv.$0} ${argv._}`;

function getExpandedImportList(apiEntry) {
  if (apiEntry && apiEntry.imports && apiEntry.imports.length) {
    const strList = [];
    apiEntry.imports.forEach(element => {
      strList.push(`	${element.name} "${element.import}"`);
    });
    return strList.join('\n');
  }
  return '';
}

function getExpandedColList(apiEntry) {
  if (apiEntry && apiEntry.cols && apiEntry.cols.length) {
    const strList = [];
    apiEntry.cols.forEach(element => {
      strList.push(`		table.${osqType2ColumnDef.get(element.osq_type)}("${element.osq_name}"),`);
    });
    return strList.join('\n');
  }
  return '';
}

function getExpandedColMapping(apiEntry) {
  if (apiEntry && apiEntry.cols && apiEntry.cols.length) {
    const strList = [];
    apiEntry.cols.forEach(element => {
      if (element.src_type.includes('uint')) {
        strList.push(`			result["${element.osq_name}"] = strconv.FormatUint(item.${element.src_name}, 10)`);
      } else {
        strList.push(`			result["${element.osq_name}"] = item.${element.src_name}`);
      }
    });
    return strList.join('\n');
  }
  return '';
}

function getExpandedArgsList(argsList) {
  if (argsList && argsList.length) {
    const strList = [];
    argsList.forEach(element => {
      if (element.includes('$GO_CONTEXT')) {
        strList.push(element.replace(/\$GO_CONTEXT/gi, 'ctx'));
      } else if (element.includes('$PROJECT_ID')) {
        strList.push(element.replace(/\$PROJECT_ID/gi, '*projectId'));
      } else if (element.includes('$ZONE')) {
        strList.push(element.replace(/\$ZONE/gi, '*zone'));
      } else {
        strList.push(element);
      }
    });
    return strList.join(', ');
  }
  return '';
}

function getExpandedPagingApiArgsList(apiEntry) {
  if (apiEntry && apiEntry.paging_api_args && apiEntry.paging_api_args.length) {
    return getExpandedArgsList(apiEntry.paging_api_args);
  }
  return '';
}

function getTemplateByServiceApi(inTemplate, apiEntry) {
  if (apiEntry && apiEntry.service_api && apiEntry.service_api.length) {
    return pope(inTemplate, { list_call_template: templates.list_call_service_api_template }, { skipUndefined: true });
  }
  return pope(inTemplate, { list_call_template: templates.list_call_template }, { skipUndefined: true });
}

function getTemplateByPagingApiType(inTemplate, apiEntry) {
  if (apiEntry && apiEntry.paging_api_type) {
    if (apiEntry.paging_api_type === 'PAGE_INVOCATION') {
      return pope(inTemplate, { expanded_pagination: templates.page_invocation_template }, { skipUndefined: true });
    }
    if (apiEntry.paging_api_type === 'PAGEABLE') {
      return pope(inTemplate, { expanded_pagination: templates.pageable_iteration_template }, { skipUndefined: true });
    }
  }

  return inTemplate;
}

function writeToFile(filename, outString, tableName) {
  try {
    fs.writeFileSync(filename, outString);
  } catch (err) {
    console.log(`error saving osquery plugin for ${tableName} to ${filename}`);
    return;
  }
  console.log(`osquery plugin for ${tableName} is saved in ${filename}`);
  return;
}

function generatePlugins(outDir) {
  if (pluginsConfig && pluginsConfig.osquery_plugins_gcp && pluginsConfig.osquery_plugins_gcp.length) {
    pluginsConfig.osquery_plugins_gcp.forEach(apiEntry => {
      console.log('processing: ' + apiEntry.name);

      if (apiEntry.skip) {
        console.log('skipping: ' + apiEntry.name);
      } else {
        Object.assign(apiEntry, { expanded_col_list: getExpandedColList(apiEntry) });
        Object.assign(apiEntry, { expanded_col_mapping: getExpandedColMapping(apiEntry) });
        Object.assign(apiEntry, { expanded_imports: getExpandedImportList(apiEntry) });
        Object.assign(apiEntry, { expanded_paging_api_args: getExpandedPagingApiArgsList(apiEntry) });

        const templateByServiceApi = getTemplateByServiceApi(templates.base_template, apiEntry);
        const template = getTemplateByPagingApiType(templateByServiceApi, apiEntry);
        const extension = pope(template, apiEntry);

        writeToFile(`${outDir}/gen${apiEntry.name}Plugin.go`, comment + extension, apiEntry.name);
      }
    });
  } else {
    console.log('osquery plugins config not found');
  }
}

function generatePluginHelper(outDir) {
  if (pluginsConfig && pluginsConfig.osquery_plugins_gcp && pluginsConfig.osquery_plugins_gcp.length) {
    const strList = [];
    pluginsConfig.osquery_plugins_gcp.forEach(apiEntry => {
      strList.push(
        `	server.RegisterPlugin(table.NewPlugin("${apiEntry.table_name}", ${apiEntry.name}Columns(), ${apiEntry.name}Generate))`
      );
    });
    const outString = pope(templates.plugin_helper_template, { plugin_list: strList.join('\n') });
    const filename = `${outDir}/genPluginHelper.go`;
    try {
      fs.writeFileSync(filename, comment + outString);
    } catch (err) {
      console.log(`error saving osquery plugin helper to ${filename}`);
      return;
    }
    console.log(`osquery plugin is saved in ${filename}`);
  }
}

async function main() {

  generatePlugins(outDir);
  generatePluginHelper(outDir);

  process.exit();
}

main();
